# Auto-generate include/version.h from VERSION file before build.
# Works as a PlatformIO extra_script (pre).

import os, re, sys, subprocess
from datetime import datetime

Import("env")

PROJECT_DIR = env["PROJECT_DIR"]
VERSION_FILE = os.path.join(PROJECT_DIR, "VERSION")
HEADER_PATH = os.path.join(PROJECT_DIR, "include", "version.h")

# -----------------------------
# Определяем строку версии
# 1) пытаемся взять последний git-тег (`git describe --tags --abbrev=0`)
# 2) если git недоступен или тегов нет – читаем fallback-файл VERSION
# -----------------------------

def read_version_from_git() -> str:
    try:
        tag = subprocess.check_output(
            ["git", "describe", "--tags", "--abbrev=0"], cwd=PROJECT_DIR
        ).decode().strip()
        return tag.lstrip("v")  # допускаем теги вида v2.8.0
    except Exception:
        return ""


def read_version_from_file() -> str:
    if not os.path.exists(VERSION_FILE):
        return "0.0.0"
    return open(VERSION_FILE).read().strip()


version_str = read_version_from_git() or read_version_from_file()

# Поддержка тегов вида `checkpoint-3.2.29`, `v3.2.29-rc1`, etc.
# Выцепляем первую подстроку, похожую на X.Y.Z; если не найдено — пробуем fallback-файл.
semver_pattern = r"(\d+)\.(\d+)\.(\d+)"
match = re.search(semver_pattern, version_str)

if not match:
    # Попробуем прочитать из VERSION как запасной вариант, даже если git-тег некорректен
    version_str_fallback = read_version_from_file()
    match = re.search(semver_pattern, version_str_fallback)
    if match:
        version_str = version_str_fallback
    else:
        sys.stderr.write(f"[auto_version] ERROR: cannot parse version from '{version_str}'. Fallback also failed.\n")
        sys.exit(1)

major, minor, patch = match.groups()

header = f"""#pragma once

// Auto-generated. DO NOT EDIT MANUALLY.
// Generated by scripts/auto_version.py at {datetime.utcnow().isoformat()}Z

#define JXCT_VERSION_MAJOR {major}
#define JXCT_VERSION_MINOR {minor}
#define JXCT_VERSION_PATCH {patch}

#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)
#define JXCT_VERSION_STRING TOSTRING(JXCT_VERSION_MAJOR) "." TOSTRING(JXCT_VERSION_MINOR) "." TOSTRING(JXCT_VERSION_PATCH)

static const char DEVICE_MANUFACTURER[] = "Eyera";
static const char DEVICE_MODEL[] = "JXCT-7in1";
static const char DEVICE_SW_VERSION[] = JXCT_VERSION_STRING;
static const char* FIRMWARE_VERSION = JXCT_VERSION_STRING;

#define JXCT_VERSION_CODE (JXCT_VERSION_MAJOR * 10000 + JXCT_VERSION_MINOR * 100 + JXCT_VERSION_PATCH)
#define JXCT_VERSION_AT_LEAST(major, minor, patch) \
    (JXCT_VERSION_CODE >= ((major) * 10000 + (minor) * 100 + (patch)))

#ifndef JXCT_BUILD_DATE
#define JXCT_BUILD_DATE __DATE__
#endif
#ifndef JXCT_BUILD_TIME
#define JXCT_BUILD_TIME __TIME__
#endif
#define JXCT_FULL_VERSION_STRING JXCT_VERSION_STRING " (built " JXCT_BUILD_DATE " " JXCT_BUILD_TIME ")"
"""

os.makedirs(os.path.dirname(HEADER_PATH), exist_ok=True)

if os.path.exists(HEADER_PATH):
    with open(HEADER_PATH, "rb") as _f:
        current = _f.read()
else:
    current = b""

new_content = header.encode("utf-8")

if current != new_content:
    with open(HEADER_PATH, "wb") as f:
        f.write(new_content)
    print(f"[auto_version] version.h regenerated to {version_str}")
else:
    print("[auto_version] version.h up-to-date") 