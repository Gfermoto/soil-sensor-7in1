#include <cstring>
#include <string>
#include "simple_csrf.h"
#include "unity_simple.h"

// –ó–∞–≥–ª—É—à–∫–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è (—á—Ç–æ–±—ã –Ω–µ –ø–æ–¥—Ç—è–≥–∏–≤–∞—Ç—å logger.cpp)
extern "C"
{
    void logSuccess(const char*, ...) {}
    void logError(const char*, ...) {}
    void logWarn(const char*, ...) {}
    void logDebug(const char*, ...) {}
    void logInfo(const char*, ...) {}
    void logSystem(const char*, ...) {}
}

// –ó–∞–≥–ª—É—à–∫–∏ –¥–ª—è Arduino –∏ FS
#include <cstdint>
#include <cstring>
#include <string>

// –ó–∞–≥–ª—É—à–∫–∏ –¥–ª—è LittleFS
namespace
{
bool littleFS_initialized = false;
bool littleFS_exists_result = false;
}  // namespace

// –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è File
class File
{
   public:
    bool available()
    {
        return false;
    }
    std::string readStringUntil(char delimiter)
    {
        return "";
    }
    void close() {}
    size_t size()
    {
        return 0;
    }
    size_t write(uint8_t byte)
    {
        return 1;
    }
};

// –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è Stream
class Stream
{
   public:
    virtual int available()
    {
        return 0;
    }
    virtual int read()
    {
        return -1;
    }
    virtual size_t write(uint8_t)
    {
        return 1;
    }
};

// –ó–∞–≥–ª—É—à–∫–∏ –¥–ª—è LittleFS
class LittleFSClass
{
   public:
    bool begin(bool formatOnFailure)
    {
        littleFS_initialized = true;
        return true;
    }

    bool exists(const char* path)
    {
        return littleFS_exists_result;
    }

    bool mkdir(const char* path)
    {
        return true;
    }

    File open(const char* path, const char* mode)
    {
        static File dummyFile;
        return dummyFile;
    }

    bool remove(const char* path)
    {
        return true;
    }
};

LittleFSClass LittleFS;

// –ó–∞–≥–ª—É—à–∫–∏ –¥–ª—è Arduino —Ñ—É–Ω–∫—Ü–∏–π
bool isDigit(char c)
{
    return c >= '0' && c <= '9';
}
int random(int min, int max)
{
    return min;
}
// –£–±–∏—Ä–∞–µ–º millis() - –æ–Ω —É–∂–µ –µ—Å—Ç—å –≤ Arduino.h

// –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è FS.h
#define FS_H
namespace fs
{
class FS
{
   public:
    virtual bool begin(bool formatOnFailure = false) = 0;
    virtual bool exists(const char* path) = 0;
    virtual bool mkdir(const char* path) = 0;
    virtual File open(const char* path, const char* mode) = 0;
    virtual bool remove(const char* path) = 0;
};
}  // namespace fs

#include "jxct_constants.h"
#include "validation_utils.h"
// –ü–æ–¥–∫–ª—é—á–∞–µ–º —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –Ω–∞–ø—Ä—è–º—É—é (–±–µ–∑ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç logger.cpp)
#include "../src/sensor_compensation.cpp"
#include "../src/validation_utils.cpp"
#include "jxct_format_utils.h"
#include "sensor_compensation.h"

void setUp(void)
{
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º —Ç–µ—Å—Ç–æ–º
}

void tearDown(void)
{
    // –û—á–∏—Å—Ç–∫–∞ –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —Ç–µ—Å—Ç–∞
}

// ============================================================================
// –ë–ê–ó–û–í–´–ï –¢–ï–°–¢–´ CSRF
// ============================================================================

void test_csrf_token_generation(void)
{
    // –¢–µ—Å—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ CSRF —Ç–æ–∫–µ–Ω–∞
    std::string token = generateCSRFToken();

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–æ–∫–µ–Ω –Ω–µ –ø—É—Å—Ç–æ–π
    TEST_ASSERT_NOT_EQUAL(0, token.length());

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–æ–∫–µ–Ω –∏–º–µ–µ—Ç —Ä–∞–∑—É–º–Ω—É—é –¥–ª–∏–Ω—É
    TEST_ASSERT_GREATER_THAN(10, token.length());

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–æ–∫–µ–Ω —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ hex —Å–∏–º–≤–æ–ª—ã
    for (char c : token)
    {
        TEST_ASSERT_TRUE((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f'));
    }
}

void test_csrf_token_validation(void)
{
    // –¢–µ—Å—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏ CSRF —Ç–æ–∫–µ–Ω–∞
    std::string token = generateCSRFToken();

    // –í–∞–ª–∏–¥–Ω—ã–π —Ç–æ–∫–µ–Ω –¥–æ–ª–∂–µ–Ω –ø—Ä–æ–π—Ç–∏ –ø—Ä–æ–≤–µ—Ä–∫—É
    TEST_ASSERT_TRUE(validateCSRFToken(token));

    // –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π —Ç–æ–∫–µ–Ω –¥–æ–ª–∂–µ–Ω –Ω–µ –ø—Ä–æ–π—Ç–∏ –ø—Ä–æ–≤–µ—Ä–∫—É
    TEST_ASSERT_FALSE(validateCSRFToken("invalid_token"));
    TEST_ASSERT_FALSE(validateCSRFToken(""));
}

void test_csrf_token_uniqueness(void)
{
    // –¢–µ—Å—Ç —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ —Ç–æ–∫–µ–Ω–æ–≤
    std::string token1 = generateCSRFToken();
    std::string token2 = generateCSRFToken();

    // –¢–æ–∫–µ–Ω—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ä–∞–∑–Ω—ã–º–∏
    TEST_ASSERT_NOT_EQUAL_STRING(token1.c_str(), token2.c_str());
}

// ============================================================================
// –†–ê–°–®–ò–†–ï–ù–ù–´–ï –¢–ï–°–¢–´ CSRF –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò
// ============================================================================

void test_csrf_token_length_consistency(void)
{
    // –¢–µ—Å—Ç –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ –¥–ª–∏–Ω—ã —Ç–æ–∫–µ–Ω–æ–≤
    std::string token1 = generateCSRFToken();
    std::string token2 = generateCSRFToken();
    std::string token3 = generateCSRFToken();

    // –í—Å–µ —Ç–æ–∫–µ–Ω—ã –¥–æ–ª–∂–Ω—ã –∏–º–µ—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—É—é –¥–ª–∏–Ω—É
    TEST_ASSERT_EQUAL(token1.length(), token2.length());
    TEST_ASSERT_EQUAL(token2.length(), token3.length());

    // –î–ª–∏–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–∞–∑—É–º–Ω–æ–π (32 —Å–∏–º–≤–æ–ª–∞ –¥–ª—è MD5)
    TEST_ASSERT_EQUAL(32, token1.length());
}

void test_csrf_token_format_validation(void)
{
    // –¢–µ—Å—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ñ–æ—Ä–º–∞—Ç–∞ —Ç–æ–∫–µ–Ω–∞
    std::string validToken = generateCSRFToken();

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
    TEST_ASSERT_FALSE(validateCSRFToken("1234567890123456789012345678901"));    // 31 —Å–∏–º–≤–æ–ª
    TEST_ASSERT_FALSE(validateCSRFToken("123456789012345678901234567890123"));  // 33 —Å–∏–º–≤–æ–ª–∞
    TEST_ASSERT_FALSE(validateCSRFToken("1234567890123456789012345678901g"));   // —Å–æ–¥–µ—Ä–∂–∏—Ç 'g'
    TEST_ASSERT_FALSE(validateCSRFToken("1234567890123456789012345678901G"));   // —Å–æ–¥–µ—Ä–∂–∏—Ç 'G'
    TEST_ASSERT_FALSE(validateCSRFToken("1234567890123456789012345678901@"));   // —Å–æ–¥–µ—Ä–∂–∏—Ç '@'
    TEST_ASSERT_FALSE(validateCSRFToken("1234567890123456789012345678901 "));   // —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—Ä–æ–±–µ–ª
}

void test_csrf_token_case_sensitivity(void)
{
    // –¢–µ—Å—Ç —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∫ —Ä–µ–≥–∏—Å—Ç—Ä—É
    std::string token = generateCSRFToken();

    // –°–æ–∑–¥–∞–µ–º –≤–µ—Ä—Å–∏—é –≤ –≤–µ—Ä—Ö–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ
    std::string upperToken = token;
    for (char& c : upperToken)
    {
        if (c >= 'a' && c <= 'f')
        {
            c = c - 'a' + 'A';
        }
    }

    // –í–µ—Ä—Ö–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–º
    TEST_ASSERT_FALSE(validateCSRFToken(upperToken));
}

void test_csrf_token_null_termination(void)
{
    // –¢–µ—Å—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ null-—Ç–µ—Ä–º–∏–Ω–∞—Ü–∏–∏
    std::string token = generateCSRFToken();

    // –î–æ–±–∞–≤–ª—è–µ–º null-—Å–∏–º–≤–æ–ª –≤ —Å–µ—Ä–µ–¥–∏–Ω—É
    std::string corruptedToken = token.substr(0, 16) + '\0' + token.substr(16);

    TEST_ASSERT_FALSE(validateCSRFToken(corruptedToken));
}

void test_csrf_token_special_characters(void)
{
    // –¢–µ—Å—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
    TEST_ASSERT_FALSE(validateCSRFToken("1234567890123456789012345678901\n"));    // newline
    TEST_ASSERT_FALSE(validateCSRFToken("1234567890123456789012345678901\r"));    // carriage return
    TEST_ASSERT_FALSE(validateCSRFToken("1234567890123456789012345678901\t"));    // tab
    TEST_ASSERT_FALSE(validateCSRFToken("1234567890123456789012345678901\x00"));  // null byte
}

void test_csrf_token_unicode_handling(void)
{
    // –¢–µ—Å—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ Unicode —Å–∏–º–≤–æ–ª–æ–≤
    TEST_ASSERT_FALSE(validateCSRFToken("1234567890123456789012345678901—Ñ"));   // –∫–∏—Ä–∏–ª–ª–∏—Ü–∞
    TEST_ASSERT_FALSE(validateCSRFToken("1234567890123456789012345678901Œ±"));   // –≥—Ä–µ—á–µ—Å–∫–∏–π
    TEST_ASSERT_FALSE(validateCSRFToken("1234567890123456789012345678901üòÄ"));  // —ç–º–æ–¥–∑–∏
}

void test_csrf_token_replay_attack(void)
{
    // –¢–µ—Å—Ç –Ω–∞ replay –∞—Ç–∞–∫—É
    std::string token1 = generateCSRFToken();
    std::string token2 = generateCSRFToken();

    // –û–±–∞ —Ç–æ–∫–µ–Ω–∞ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∞–ª–∏–¥–Ω—ã–º–∏, –Ω–æ —Ä–∞–∑–Ω—ã–º–∏
    TEST_ASSERT_TRUE(validateCSRFToken(token1));
    TEST_ASSERT_TRUE(validateCSRFToken(token2));
    TEST_ASSERT_NOT_EQUAL_STRING(token1.c_str(), token2.c_str());
}

void test_csrf_token_entropy(void)
{
    // –¢–µ—Å—Ç —ç–Ω—Ç—Ä–æ–ø–∏–∏ —Ç–æ–∫–µ–Ω–æ–≤ (–±–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞)
    std::string token1 = generateCSRFToken();
    std::string token2 = generateCSRFToken();
    std::string token3 = generateCSRFToken();

    // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –≤ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –ø–æ–∑–∏—Ü–∏—è—Ö
    int sameChars = 0;
    for (size_t i = 0; i < token1.length(); i++)
    {
        if (token1[i] == token2[i] && token2[i] == token3[i])
        {
            sameChars++;
        }
    }

    // –ù–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –≤ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –ø–æ–∑–∏—Ü–∏—è—Ö
    // (—ç—Ç–æ —É–∫–∞–∑—ã–≤–∞–ª–æ –±—ã –Ω–∞ —Å–ª–∞–±—É—é —ç–Ω—Ç—Ä–æ–ø–∏—é)
    TEST_ASSERT_LESS_THAN(8, sameChars);  // –ú–∞–∫—Å–∏–º—É–º 25% –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –ø–æ–∑–∏—Ü–∏–π
}

void test_csrf_token_boundary_conditions(void)
{
    // –¢–µ—Å—Ç –≥—Ä–∞–Ω–∏—á–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π
    TEST_ASSERT_FALSE(validateCSRFToken(""));                                  // –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞
    TEST_ASSERT_FALSE(validateCSRFToken("a"));                                 // –û–¥–∏–Ω —Å–∏–º–≤–æ–ª
    TEST_ASSERT_FALSE(validateCSRFToken("123456789012345678901234567890"));    // 30 —Å–∏–º–≤–æ–ª–æ–≤
    TEST_ASSERT_FALSE(validateCSRFToken("12345678901234567890123456789012"));  // 32 —Å–∏–º–≤–æ–ª–∞, –Ω–æ –Ω–µ hex
}

void test_csrf_token_memory_safety(void)
{
    // –¢–µ—Å—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –ø–∞–º—è—Ç–∏ (–±–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞)
    for (int i = 0; i < 100; i++)
    {
        std::string token = generateCSRFToken();
        TEST_ASSERT_TRUE(validateCSRFToken(token));
        TEST_ASSERT_EQUAL(32, token.length());
    }
}

// ============================================================================
// –¢–ï–°–¢–´ –í–ê–õ–ò–î–ê–¶–ò–ò
// ============================================================================

void test_validate_ssid_empty(void)
{
    ValidationResult res = validateSSID("");
    TEST_ASSERT_FALSE(res.isValid);
}

void test_validate_ssid_too_long(void)
{
    String ssid(33, 'a');
    ValidationResult res = validateSSID(ssid);
    TEST_ASSERT_FALSE(res.isValid);
}

void test_validate_ssid_valid(void)
{
    ValidationResult res = validateSSID("my_wifi");
    TEST_ASSERT_TRUE(res.isValid);
}

void test_validate_password_short(void)
{
    ValidationResult res = validatePassword("short");
    TEST_ASSERT_FALSE(res.isValid);
}

void test_validate_password_long(void)
{
    String pwd(64, 'p');
    ValidationResult res = validatePassword(pwd);
    TEST_ASSERT_FALSE(res.isValid);
}

void test_validate_password_valid(void)
{
    ValidationResult res = validatePassword("supersecret");
    TEST_ASSERT_TRUE(res.isValid);
}

void test_validate_mqtt_port_low(void)
{
    ValidationResult res = validateMQTTPort(0);
    TEST_ASSERT_FALSE(res.isValid);
}

void test_validate_mqtt_port_high(void)
{
    ValidationResult res = validateMQTTPort(70000);
    TEST_ASSERT_FALSE(res.isValid);
}

void test_validate_mqtt_port_valid(void)
{
    ValidationResult res = validateMQTTPort(1883);
    TEST_ASSERT_TRUE(res.isValid);
}

void test_validate_temperature_low(void)
{
    ValidationResult res = validateTemperature(SENSOR_TEMP_MIN - 1);
    TEST_ASSERT_FALSE(res.isValid);
}

void test_validate_temperature_high(void)
{
    ValidationResult res = validateTemperature(SENSOR_TEMP_MAX + 1);
    TEST_ASSERT_FALSE(res.isValid);
}

void test_validate_temperature_valid(void)
{
    ValidationResult res = validateTemperature(25.0F);
    TEST_ASSERT_TRUE(res.isValid);
}

void test_validate_humidity_low(void)
{
    ValidationResult res = validateHumidity(SENSOR_HUMIDITY_MIN - 1);
    TEST_ASSERT_FALSE(res.isValid);
}

void test_validate_humidity_high(void)
{
    ValidationResult res = validateHumidity(SENSOR_HUMIDITY_MAX + 1);
    TEST_ASSERT_FALSE(res.isValid);
}

void test_validate_humidity_valid(void)
{
    ValidationResult res = validateHumidity(60.0F);
    TEST_ASSERT_TRUE(res.isValid);
}

void test_validate_ph_low(void)
{
    ValidationResult res = validatePH(SENSOR_PH_MIN - 0.1F);
    TEST_ASSERT_FALSE(res.isValid);
}

void test_validate_ph_high(void)
{
    ValidationResult res = validatePH(SENSOR_PH_MAX + 0.1F);
    TEST_ASSERT_FALSE(res.isValid);
}

void test_validate_ph_valid(void)
{
    ValidationResult res = validatePH(6.5F);
    TEST_ASSERT_TRUE(res.isValid);
}

// ============================================================================
// –¢–ï–°–¢–´ –§–û–†–ú–ê–¢–ò–†–û–í–ê–ù–ò–Ø
// ============================================================================

void test_format_temperature(void)
{
    std::string s = format_temperature(23.456f);
    TEST_ASSERT_EQUAL_STRING("23.5", s.c_str());
}

void test_format_ec(void)
{
    std::string s = format_ec(1234.7f);
    TEST_ASSERT_EQUAL_STRING("1235", s.c_str());
}

void test_format_ph(void)
{
    std::string s = format_ph(6.78f);
    TEST_ASSERT_EQUAL_STRING("6.8", s.c_str());
}

void test_format_value_prec0(void)
{
    String s = formatValue(25.4f, "¬∞C", 0);
    TEST_ASSERT_EQUAL_STRING("25¬∞C", s.c_str());
}

void test_format_value_prec2(void)
{
    String s = formatValue(3.1415f, "pH", 2);
    TEST_ASSERT_EQUAL_STRING("3.14pH", s.c_str());
}

// ============================================================================
// –¢–ï–°–¢–´ –ö–û–ú–ü–ï–ù–°–ê–¶–ò–ò
// ============================================================================

void test_correct_ph_baseline(void)
{
    float res = correctPH(7.0f, 25.0f);
    TEST_ASSERT_FLOAT_WITHIN(1e-5f, 7.0f, res);
}

void test_correct_ph_hot(void)
{
    float res = correctPH(7.0f, 35.0f);
    TEST_ASSERT_FLOAT_WITHIN(1e-4f, 6.97f, res);
}

void test_correct_ec_saturated(void)
{
    float res = correctEC(1000.0f, 25.0f, 45.0f, SoilType::LOAM);
    TEST_ASSERT_FLOAT_WITHIN(0.01f, 1000.0f, res);
}

void test_correct_ec_low_moisture(void)
{
    float res = correctEC(1000.0f, 25.0f, 30.0f, SoilType::LOAM);
    TEST_ASSERT_GREATER_THAN(1000.0f, res);
}

void test_correct_npk_out_of_range(void)
{
    float N = 100, P = 100, K = 100;
    correctNPK(25.0f, 20.0f, N, P, K, SoilType::LOAM);
    TEST_ASSERT_FLOAT_WITHIN(1e-5f, 100.0f, N);
    TEST_ASSERT_FLOAT_WITHIN(1e-5f, 100.0f, P);
    TEST_ASSERT_FLOAT_WITHIN(1e-5f, 100.0f, K);
}

void test_correct_npk_increase(void)
{
    float N = 100, P = 100, K = 100;
    correctNPK(25.0f, 30.0f, N, P, K, SoilType::LOAM);
    TEST_ASSERT_GREATER_THAN(100.0f, N);
    TEST_ASSERT_GREATER_THAN(100.0f, P);
    TEST_ASSERT_GREATER_THAN(100.0f, K);
}

// ============================================================================
// –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø
// ============================================================================

int main(void)
{
    UNITY_BEGIN();

    // –ë–∞–∑–æ–≤—ã–µ —Ç–µ—Å—Ç—ã CSRF
    RUN_TEST(test_csrf_token_generation);
    RUN_TEST(test_csrf_token_validation);
    RUN_TEST(test_csrf_token_uniqueness);

    // –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã CSRF –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    RUN_TEST(test_csrf_token_length_consistency);
    RUN_TEST(test_csrf_token_format_validation);
    RUN_TEST(test_csrf_token_case_sensitivity);
    RUN_TEST(test_csrf_token_null_termination);
    RUN_TEST(test_csrf_token_special_characters);
    RUN_TEST(test_csrf_token_unicode_handling);
    RUN_TEST(test_csrf_token_replay_attack);
    RUN_TEST(test_csrf_token_entropy);
    RUN_TEST(test_csrf_token_boundary_conditions);
    RUN_TEST(test_csrf_token_memory_safety);

    // –¢–µ—Å—Ç—ã –≤–∞–ª–∏–¥–∞—Ü–∏–∏
    RUN_TEST(test_validate_ssid_empty);
    RUN_TEST(test_validate_ssid_too_long);
    RUN_TEST(test_validate_ssid_valid);
    RUN_TEST(test_validate_password_short);
    RUN_TEST(test_validate_password_long);
    RUN_TEST(test_validate_password_valid);
    RUN_TEST(test_validate_mqtt_port_low);
    RUN_TEST(test_validate_mqtt_port_high);
    RUN_TEST(test_validate_mqtt_port_valid);
    RUN_TEST(test_validate_temperature_low);
    RUN_TEST(test_validate_temperature_high);
    RUN_TEST(test_validate_temperature_valid);
    RUN_TEST(test_validate_humidity_low);
    RUN_TEST(test_validate_humidity_high);
    RUN_TEST(test_validate_humidity_valid);
    RUN_TEST(test_validate_ph_low);
    RUN_TEST(test_validate_ph_high);
    RUN_TEST(test_validate_ph_valid);

    // –¢–µ—Å—Ç—ã —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    RUN_TEST(test_format_temperature);
    RUN_TEST(test_format_ec);
    RUN_TEST(test_format_ph);
    RUN_TEST(test_format_value_prec0);
    RUN_TEST(test_format_value_prec2);

    // –¢–µ—Å—Ç—ã –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏–∏
    RUN_TEST(test_correct_ph_baseline);
    RUN_TEST(test_correct_ph_hot);
    RUN_TEST(test_correct_ec_saturated);
    RUN_TEST(test_correct_ec_low_moisture);
    RUN_TEST(test_correct_npk_out_of_range);
    RUN_TEST(test_correct_npk_increase);

    return UNITY_END();
}
